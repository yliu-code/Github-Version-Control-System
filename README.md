# GithubVCS
A version control system used to control local file versions.


## Rationale
In GithubVCS, I try to implement a version-control system, which is essentially a backup system for files. I use Commit to backup directories of files whose contents are kept as Blobs. I use tree as the structure of directory for the convenience of mapping names to references to blobs and other trees(subdirectories). 
I store everything in the Hashmaps as a String instead of pointers to objects because I plan to serialize all the Blob and Commit objects and retrieving them using the String names. This way, I can simply store 1 copy of every unique version of each file, and one copy of each commit in spite of the possibility of multiple branches.
I considered serializing Command, but since I am only storing Hashmaps / Hashsets of Strings, it would be inefficient to serialize and deserialize the hashmaps just to access a single / few elements. Instead I only store hashmaps.


## Data Structures and Functions

## Blob {
// Constructor
        Blob            //the constructor of the class Blob
// Fields
        String id;            // iD hash from sha-1
File file            // specific file contained in blob
String fileName;        // Name of file
String fileDir;        // Name of directory to find file
Byte[] content        // Content of file stored as byte array
// Methods
getiD()            // Retrieve iD of blob with sha-1
getFile()            // retrieve file
getFileName()        // retrieve filename
getContent()        // get content using utils provided}
## Commit {
// Fields
      String id                    // unique id generated by sha-1 
      Hashmap tree<S, B>;                       // maps name to blobs
      String parent;                                      // id of parent, null if initial commit
      String logMessage                // store commit messages
      Date timeStamp                // time of commit
// Methods
getID()
getTree()
getParent()
getLogMessage()
getTimeStamp()}

## Control {    
// Specifies the implementation of git commands passed in main args
// Field    
String head                // name of branch head is on (on latest commit in branch)
HashSet stage<S>            // keeps track of files added to staging area
HashSet untracked<S>        // track untracked file
HashSet removed<S>            // track removed file
HashMap commits<S, S>        // map commit id to commit messages
HashMap branches<S, S>        // map branch to latest commit in branch

// Method
Monday
init()                    // create .gitlet repo, initial commit, master branch
add(String fileName)            // add file to hashset stage
commit(String log)            // create new commit with parent as previous commit
                    // add staged file to tree, initialize new commit
rm(String name)            // remove file from stage, add to Hashset removed
Tuesday
log()                    // display commit metadata until init commit
glog()                    // display all commit info
find(String msg)            // print id of commit with given msg
status()                // display all cur branch, staged, rm, not stage, untrack
Wednesday
checkoutF(String filename)        // place file from head in wd, overwrite, add to untracked
checkoutC(String id, String filename)    // place file from commit in wd, overwrite, etc. ...
checkoutB(String branchname)    // place all file from branch in wd, branch is head, clear sa
Thursday
branch()                // create branch, point branch to head node
rm-branch()                // delete branch with name from branches
reset(String id)                // checkout commit with id, move head to commit
merge(String branch)            // change overload files from next branch to new branch}
Friday
Serialize

## Main {
main(String args[]) {}        // process args and call Commands}
Algorithms

## Commands
init(): 
Create .gitlet repo
Create first commit with message initial commit
Create branch master,  point to initial commit
Create HEAD, a special pointer to the branch we are currently on. 
add(String fileName):
Check if file id identical to file with same name in curr commit
Find file from wd using filename
Remove filename from removed
Add copy of file to stage            
commit(String log):
Create new commit with msg pointing to last commit
Create blob for each file in staging area, inserting blob into tree
Check blobs from previous commit and add blob id into new commit 
HOWEVER ^^ if file is in untracked, do not add corresponding blob id
Clear staging area
Point current branch’s head pointer to new commit            
rm(String name):
If file in stage, remove from stage
If file not in stage, delete file from wd and add file to untracked            
log():
Starting at head commit, print id, timestamp, logmessage
Point to parent of this commit, and use recursion
Print init commit info and stop recursion.                
global-log()*                
Print all values (logmessages) of commits hashmap
find(String msg)*            
Print all keys (commit id) of commits hashmap with given msg
If no such key is found, print “found no commit with that message”
status()    *
Print all branch id in branches, add “*” before head branch
Print all file name in stage
Print all file name in removed
Print “=== Modifications Not Staged For Commit ===”
Print ”=== Untracked Files ===”
checkoutF(String filename)        
Find if there’s a file with the file name in the current head
If there is one, check it out, put it in the working directory and overwrite it
If there isn’t, throw error.     
checkoutC(String id, String filename)    
Loop through each commits on a branch to find the commit with this commit id
If not find - throw error message
If find Check if the file name exists, if not - throw error message
If find, overwrite file in wd
checkoutB(String branchname)    
Place all files in tree of given branch in wd
If branchname same as head, skip following parts
Change head to branchname
Clear staging area
Delete files not in checked out branch from wd, add to removed
branch(String branchname)*    
Check if this branch name already exists, if yes - throw error message
If branches empty, add branch master, point to init commit
Add branchname to branches, add value as current commit
rm-branch()*
Check if the given branch exists, if not, print out error message: A branch with that name does not exist.
Check if the given branch is the current branch, if is so, print error message:     Cannot remove the current branch.     
Delete branch name entry from branches    
reset(String id)        
Iterate through tree of commit checkoutF all files
Change current branch and head to commit
merge(String branch)
Given branch is ancestor of curr branch, do nothing 
If curr branch is ancestor of given branch, point given to curr commit
Else
If file mod in given since split, checkout file in given and add to stage
File not mod in given stays the same
Files present only in given checked out and staged
Files present only in current should be removed / untracked
Resolve merge conflicts}

## Persistence
In order to control versions of the files, we need to persist gitlet to disk. We can achieve this by:
Creating a .gitlet directory 
Writing Commit to disk, writing staging area, other hashmaps to disk
Saving contents of file, filename to blob and writing blob to disk’
We can do the above by saving this as a string in a text file or use serialize to convert the Java object into bytes that we can eventually write to a file with sha-1 unique id on disk. 

In order to checkout, we need to search for the saved Commit objects and files. 
To do this, we need to:
Look for the unique SHA-1 id of the Commit.
Loop through the Hashmap contents of the commit and get the SHA-1 of all the files we need. 
Use the SHA-1 of all the files to get access to all files.
Deserialize to convert files into original ones. 
